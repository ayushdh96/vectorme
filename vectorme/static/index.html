<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VectorMe - Voice Recording & Speaker Diarization</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/record.esm.js" type="module"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .waveform-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 16px;
            min-height: 70px;
        }
        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-record {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
            color: white;
        }
        .btn-record:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(255, 65, 108, 0.4);
        }
        .btn-record.recording {
            animation: pulse 1.5s infinite;
        }
        .btn-stop {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        .btn-stop:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }
        .btn-play {
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white;
        }
        .btn-play:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(56, 239, 125, 0.4);
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 65, 108, 0.7); }
            50% { box-shadow: 0 0 0 15px rgba(255, 65, 108, 0); }
        }
        .status {
            text-align: center;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        .status.recording {
            background: rgba(255, 65, 108, 0.2);
            color: #ff6b8a;
        }
        .status.processing {
            background: rgba(102, 126, 234, 0.2);
            color: #a0b0ff;
        }
        .status.ready {
            background: rgba(56, 239, 125, 0.2);
            color: #6bffb3;
        }
        .diarization-results {
            margin-top: 20px;
        }
        .diarization-results h3 {
            margin-bottom: 16px;
            color: #a0b0ff;
        }
        .segment {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }
        .segment:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .segment-time {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            color: #888;
            min-width: 120px;
        }
        .segment-speaker {
            flex: 1;
            font-weight: 600;
            padding: 4px 12px;
            border-radius: 4px;
            display: inline-block;
        }
        .segment-speaker.unknown {
            background: rgba(255, 255, 255, 0.1);
            color: #999;
        }
        .segment-speaker.known {
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            color: white;
            box-shadow: 0 0 8px rgba(0, 210, 255, 0.5), 0 0 16px rgba(58, 123, 213, 0.3);
            animation: speakerGlow 2s ease-in-out infinite alternate;
        }
        @keyframes speakerGlow {
            from { box-shadow: 0 0 8px rgba(0, 210, 255, 0.4), 0 0 16px rgba(58, 123, 213, 0.2); }
            to { box-shadow: 0 0 12px rgba(0, 210, 255, 0.6), 0 0 24px rgba(58, 123, 213, 0.4); }
        }
        .segment-similarity {
            font-size: 14px;
            color: #666;
            margin-left: 12px;
        }
        .timeline {
            position: relative;
            height: 40px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 20px;
            overflow: hidden;
        }
        .timeline-segment {
            position: absolute;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            white-space: nowrap;
        }
        .speaker-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }
        .speaker-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.15), 0 0 16px rgba(255, 255, 255, 0.1);
            transition: box-shadow 0.3s ease;
        }
        .speaker-badge:hover {
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.25), 0 0 24px rgba(255, 255, 255, 0.15);
        }
        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .live-dot {
            width: 8px;
            height: 8px;
            background: #ff4b2b;
            border-radius: 50%;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .events-log {
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
        }
        .event-item {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        .event-item:last-child {
            border-bottom: none;
        }
        .event-type {
            color: #00d2ff;
        }
        .segment-play-icon {
            color: #4a9eff;
            font-size: 12px;
            margin-left: auto;
            opacity: 0.5;
            transition: opacity 0.2s ease;
        }
        .segment:hover .segment-play-icon {
            opacity: 1;
        }
        .segment-name-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #a0b0ff;
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.2s ease;
        }
        .segment-name-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            min-width: 320px;
            max-width: 90vw;
        }
        .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #fff;
        }
        .modal-section {
            margin-bottom: 16px;
        }
        .modal-section-title {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .modal-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 14px;
        }
        .modal-input:focus {
            outline: none;
            border-color: #4a9eff;
        }
        .modal-speakers {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .modal-speaker-option {
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }
        .modal-speaker-option:hover {
            transform: scale(1.05);
        }
        .modal-speaker-option.selected {
            border-color: #fff;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.3);
        }
        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .modal-btn-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }
        .modal-btn-cancel:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }
        .modal-btn-save {
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            color: white;
        }
        .modal-btn-save:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(0, 210, 255, 0.4);
        }
        .modal-btn-save:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .modal-info {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
        }
        .btn-reprocess {
            background: linear-gradient(135deg, #f7971e, #ffd200);
            color: #1a1a2e;
            padding: 8px 16px;
            font-size: 13px;
        }
        .btn-reprocess:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(247, 151, 30, 0.4);
        }
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        .card-header h3 {
            margin: 0;
        }
        .segment.active {
            background: rgba(74, 158, 255, 0.2);
            border: 1px solid rgba(74, 158, 255, 0.5);
        }
        .timeline-segment.active {
            box-shadow: 0 0 0 2px #fff, 0 0 10px rgba(74, 158, 255, 0.8);
            z-index: 10;
        }
        .timeline-info {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            padding: 8px 12px;
            background: rgba(74, 158, 255, 0.1);
            border-radius: 6px;
            font-size: 13px;
        }
        .timeline-info-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .timeline-info-label {
            color: #888;
        }
        .timeline-info-value {
            color: #4a9eff;
            font-weight: 600;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        /* Mobile-friendly responsive styles */
        @media (max-width: 768px) {
            body {
                padding: 12px;
            }
            h1 {
                font-size: 1.5rem;
                margin-bottom: 16px;
            }
            .card {
                padding: 16px;
                margin-bottom: 12px;
                border-radius: 12px;
            }
            .waveform-container {
                padding: 12px;
                min-height: 60px;
                margin-bottom: 12px;
            }
            button {
                padding: 10px 18px;
                font-size: 14px;
            }
            .status {
                padding: 8px;
                margin-bottom: 12px;
                font-size: 14px;
            }
            .segment {
                padding: 10px 12px;
                flex-wrap: wrap;
                gap: 8px;
            }
            .segment-time {
                font-size: 12px;
                min-width: auto;
            }
            .segment-speaker {
                padding: 3px 10px;
                font-size: 13px;
            }
            .timeline {
                height: 32px;
            }
            .timeline-segment {
                font-size: 10px;
            }
            .speaker-list {
                gap: 6px;
            }
            .speaker-badge {
                padding: 4px 10px;
                font-size: 12px;
            }
            .events-log {
                font-size: 10px;
                padding: 8px;
                max-height: 150px;
            }
            .timeline-info {
                flex-direction: column;
                gap: 4px;
                font-size: 11px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 8px;
            }
            h1 {
                font-size: 1.25rem;
                margin-bottom: 12px;
            }
            .card {
                padding: 12px;
                margin-bottom: 10px;
            }
            .waveform-container {
                padding: 8px;
                min-height: 50px;
                margin-bottom: 10px;
            }
            .segment-time {
                width: 100%;
                margin-bottom: 4px;
            }
            .segment-speaker {
                flex: none;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Speaker colors for timeline
        const SPEAKER_COLORS = [
            '#ff416c', '#667eea', '#11998e', '#f7971e', '#8e44ad',
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'
        ];

        function getSpeakerColor(speaker, speakerMap) {
            if (!speaker) return 'rgba(128, 128, 128, 0.5)';
            if (!speakerMap.has(speaker)) {
                speakerMap.set(speaker, SPEAKER_COLORS[speakerMap.size % SPEAKER_COLORS.length]);
            }
            return speakerMap.get(speaker);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(1);
            return `${mins}:${secs.padStart(4, '0')}`;
        }

        function VoiceRecorder() {
            const [isRecording, setIsRecording] = useState(false);
            const [isPlaying, setIsPlaying] = useState(false);
            const [status, setStatus] = useState('ready');
            const [statusText, setStatusText] = useState('Ready to record');
            const [audioBlob, setAudioBlob] = useState(null);
            const [duration, setDuration] = useState(0);
            const [segments, setSegments] = useState([]);
            const [events, setEvents] = useState([]);
            const [speakers, setSpeakers] = useState([]);
            const [speakerMap] = useState(new Map());
            const [activeSegment, setActiveSegment] = useState(null);
            const [namingSegment, setNamingSegment] = useState(null);
            const [newSpeakerName, setNewSpeakerName] = useState('');
            const [selectedExistingSpeaker, setSelectedExistingSpeaker] = useState(null);
            const [isSaving, setIsSaving] = useState(false);
            const [knownSpeakers, setKnownSpeakers] = useState([]);

            const waveformRef = useRef(null);
            const playbackWaveformRef = useRef(null);
            const wavesurferRef = useRef(null);
            const playbackWavesurferRef = useRef(null);
            const mediaRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);
            const streamRef = useRef(null);
            const processingRef = useRef(false);
            const lastProcessedChunkRef = useRef(0);
            const activeSegmentRef = useRef(null);
            const canvasRef = useRef(null);
            const audioContextRef = useRef(null);
            const analyserRef = useRef(null);
            const animationRef = useRef(null);

            // Initialize recording waveform
            useEffect(() => {
                if (waveformRef.current && !wavesurferRef.current) {
                    wavesurferRef.current = WaveSurfer.create({
                        container: waveformRef.current,
                        waveColor: '#4a9eff',
                        progressColor: '#00d2ff',
                        cursorColor: '#fff',
                        barWidth: 2,
                        barGap: 1,
                        barRadius: 2,
                        height: 50,
                        normalize: true,
                    });
                }

                return () => {
                    if (wavesurferRef.current) {
                        wavesurferRef.current.destroy();
                        wavesurferRef.current = null;
                    }
                };
            }, []);

            // Initialize playback waveform when audio is available
            useEffect(() => {
                if (playbackWaveformRef.current && audioBlob && !playbackWavesurferRef.current) {
                    playbackWavesurferRef.current = WaveSurfer.create({
                        container: playbackWaveformRef.current,
                        waveColor: '#4a9eff',
                        progressColor: '#00d2ff',
                        cursorColor: '#fff',
                        barWidth: 2,
                        barGap: 1,
                        barRadius: 2,
                        height: 50,
                        normalize: true,
                    });

                    const url = URL.createObjectURL(audioBlob);
                    playbackWavesurferRef.current.load(url);

                    playbackWavesurferRef.current.on('finish', () => {
                        setIsPlaying(false);
                    });

                    playbackWavesurferRef.current.on('play', () => {
                        setIsPlaying(true);
                    });

                    playbackWavesurferRef.current.on('pause', () => {
                        setIsPlaying(false);
                    });

                    // Listen for timeupdate to stop at segment end
                    playbackWavesurferRef.current.on('timeupdate', (currentTime) => {
                        if (activeSegmentRef.current && currentTime >= activeSegmentRef.current.end) {
                            playbackWavesurferRef.current.pause();
                            setActiveSegment(null);
                            activeSegmentRef.current = null;
                        }
                    });
                }

                return () => {
                    if (playbackWavesurferRef.current) {
                        playbackWavesurferRef.current.destroy();
                        playbackWavesurferRef.current = null;
                    }
                };
            }, [audioBlob]);

            const startRecording = useCallback(async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            channelCount: 1,
                            sampleRate: 16000,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    streamRef.current = stream;

                    // Clear previous state
                    audioChunksRef.current = [];
                    lastProcessedChunkRef.current = 0;
                    processingRef.current = false;
                    setSegments([]);
                    setEvents([]);
                    setSpeakers([]);
                    speakerMap.clear();
                    setActiveSegment(null);
                    activeSegmentRef.current = null;

                    // Cleanup previous playback wavesurfer
                    if (playbackWavesurferRef.current) {
                        playbackWavesurferRef.current.destroy();
                        playbackWavesurferRef.current = null;
                    }
                    setAudioBlob(null);

                    // Create MediaRecorder
                    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                        ? 'audio/webm;codecs=opus' 
                        : 'audio/webm';
                    
                    mediaRecorderRef.current = new MediaRecorder(stream, { mimeType });

                    mediaRecorderRef.current.ondataavailable = async (event) => {
                        if (event.data.size > 0) {
                            audioChunksRef.current.push(event.data);
                            
                            // Stream to backend every 3 chunks (3 seconds) for real-time results
                            if (audioChunksRef.current.length >= 3 && 
                                audioChunksRef.current.length % 2 === 0 &&
                                !processingRef.current) {
                                const blob = new Blob(audioChunksRef.current, { type: mimeType });
                                // Process in background, don't await
                                processStreamingDiarization(blob, true);
                            }
                        }
                    };

                    mediaRecorderRef.current.onstop = async () => {
                        const blob = new Blob(audioChunksRef.current, { type: mimeType });
                        setAudioBlob(blob);
                        
                        // Final diarization with complete audio
                        await processStreamingDiarization(blob, false);
                    };

                    // Start recording with timeslice for streaming (1 second chunks)
                    mediaRecorderRef.current.start(1000);
                    setIsRecording(true);
                    setStatus('recording');
                    setStatusText('Recording... Results will appear in real-time');

                    // Start live visualization using AudioContext
                    const audioContext = new AudioContext();
                    audioContextRef.current = audioContext;
                    const source = audioContext.createMediaStreamSource(stream);
                    const analyser = audioContext.createAnalyser();
                    analyserRef.current = analyser;
                    analyser.fftSize = 2048;
                    source.connect(analyser);

                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);

                    const drawWaveform = () => {
                        if (mediaRecorderRef.current?.state !== 'recording') {
                            animationRef.current = null;
                            return;
                        }
                        
                        animationRef.current = requestAnimationFrame(drawWaveform);
                        
                        const canvas = canvasRef.current;
                        if (!canvas) return;
                        
                        const ctx = canvas.getContext('2d');
                        const width = canvas.width;
                        const height = canvas.height;
                        
                        analyser.getByteTimeDomainData(dataArray);
                        
                        // Clear canvas
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.fillRect(0, 0, width, height);
                        
                        // Draw waveform
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = '#4a9eff';
                        ctx.beginPath();
                        
                        const sliceWidth = width / bufferLength;
                        let x = 0;
                        
                        for (let i = 0; i < bufferLength; i++) {
                            const v = dataArray[i] / 128.0;
                            const y = (v * height) / 2;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                            x += sliceWidth;
                        }
                        
                        ctx.lineTo(width, height / 2);
                        ctx.stroke();
                        
                        // Draw center line
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, height / 2);
                        ctx.lineTo(width, height / 2);
                        ctx.stroke();
                        
                        // Add glow effect based on intensity
                        const average = dataArray.reduce((a, b) => a + Math.abs(b - 128), 0) / bufferLength;
                        const intensity = Math.min(average / 50, 1);
                        waveformRef.current.style.boxShadow = `inset 0 0 ${20 + intensity * 30}px rgba(74, 158, 255, ${intensity * 0.5})`;
                    };
                    
                    drawWaveform();

                } catch (error) {
                    console.error('Error starting recording:', error);
                    setStatus('ready');
                    setStatusText('Error: Could not access microphone');
                }
            }, [speakerMap, processStreamingDiarization]);

            const stopRecording = useCallback(() => {
                if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                    mediaRecorderRef.current.stop();
                }
                if (streamRef.current) {
                    streamRef.current.getTracks().forEach(track => track.stop());
                    streamRef.current = null;
                }
                // Cancel animation frame
                if (animationRef.current) {
                    cancelAnimationFrame(animationRef.current);
                    animationRef.current = null;
                }
                // Close audio context
                if (audioContextRef.current) {
                    audioContextRef.current.close();
                    audioContextRef.current = null;
                }
                setIsRecording(false);
                setStatus('processing');
                setStatusText('Finalizing analysis...');
                
                // Reset waveform glow
                if (waveformRef.current) {
                    waveformRef.current.style.boxShadow = 'none';
                }
            }, []);

            const handleDiarizationEvent = useCallback((event) => {
                setEvents(prev => [...prev, event]);

                switch (event.event) {
                    case 'start':
                        setDuration(event.duration);
                        setSpeakers(event.speakers || []);
                        break;
                    case 'segment':
                        setSegments(prev => [...prev, {
                            start: event.start,
                            end: event.end,
                            speaker: event.speaker
                        }]);
                        break;
                    case 'speaker_change':
                        // Speaker change events are handled in real-time
                        break;
                    case 'done':
                        if (!mediaRecorderRef.current || mediaRecorderRef.current.state !== 'recording') {
                            setStatus('ready');
                            setStatusText('Analysis complete');
                        }
                        break;
                }
            }, []);

            const processStreamingDiarization = useCallback(async (blob, isPartial = false) => {
                if (processingRef.current) return;
                processingRef.current = true;

                try {
                    const formData = new FormData();
                    formData.append('file', blob, 'recording.webm');
                    formData.append('response_format', 'diarized_json');
                    formData.append('stream', 'true');
                    formData.append('vad', 'true');
                    formData.append('chunk_size', '2.0');
                    formData.append('chunk_hop', '0.5');

                    const response = await fetch('/v1/audio/transcriptions', {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';

                    // Collect all segments and events from this response before updating state
                    const newSegments = [];
                    const newEvents = [];
                    let newDuration = duration;
                    let newSpeakers = speakers;

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            if (line.trim()) {
                                try {
                                    const event = JSON.parse(line);
                                    newEvents.push(event);
                                    
                                    // Process event data locally
                                    switch (event.event) {
                                        case 'start':
                                            newDuration = event.duration;
                                            newSpeakers = event.speakers || [];
                                            break;
                                        case 'segment':
                                            newSegments.push({
                                                start: event.start,
                                                end: event.end,
                                                speaker: event.speaker
                                            });
                                            break;
                                    }
                                } catch (e) {
                                    console.error('Error parsing event:', e);
                                }
                            }
                        }
                    }

                    // Batch update state once after all data is collected (prevents flicker)
                    if (isPartial) {
                        // For partial updates, replace all segments at once
                        setSegments(newSegments);
                        setEvents(newEvents);
                    } else {
                        // For final update, replace everything
                        setSegments(newSegments);
                        setEvents(newEvents);
                    }
                    setDuration(newDuration);
                    setSpeakers(newSpeakers);

                    if (!isPartial) {
                        setStatus('ready');
                        setStatusText('Recording complete - Click play to listen');
                    }

                } catch (error) {
                    console.error('Error processing diarization:', error);
                    if (!isPartial) {
                        setStatus('ready');
                        setStatusText('Error processing audio');
                    }
                } finally {
                    processingRef.current = false;
                }
            }, [duration, speakers]);

            const togglePlayback = useCallback(() => {
                if (playbackWavesurferRef.current) {
                    playbackWavesurferRef.current.playPause();
                }
            }, []);

            const seekToSegment = useCallback((segment) => {
                if (playbackWavesurferRef.current && duration > 0) {
                    // Set active segment for tracking
                    setActiveSegment(segment);
                    activeSegmentRef.current = segment;
                    
                    // Seek to the position (0-1 range)
                    const position = segment.start / duration;
                    playbackWavesurferRef.current.seekTo(position);
                    // Start playing
                    playbackWavesurferRef.current.play();
                }
            }, [duration]);

            const clearActiveSegment = useCallback(() => {
                setActiveSegment(null);
                activeSegmentRef.current = null;
            }, []);

            // Fetch known speakers on mount
            useEffect(() => {
                fetch('/v1/speakers')
                    .then(res => res.json())
                    .then(data => setKnownSpeakers(data.speakers || []))
                    .catch(err => console.error('Error fetching speakers:', err));
            }, []);

            const openNamingModal = useCallback((segment, e) => {
                e.stopPropagation();
                setNamingSegment(segment);
                setNewSpeakerName('');
                setSelectedExistingSpeaker(null);
                // Refresh speaker list
                fetch('/v1/speakers')
                    .then(res => res.json())
                    .then(data => setKnownSpeakers(data.speakers || []))
                    .catch(err => console.error('Error fetching speakers:', err));
            }, []);

            const closeNamingModal = useCallback(() => {
                setNamingSegment(null);
                setNewSpeakerName('');
                setSelectedExistingSpeaker(null);
            }, []);

            const saveSegmentSpeaker = useCallback(async () => {
                if (!namingSegment || !audioBlob) return;
                
                const speakerName = selectedExistingSpeaker || newSpeakerName.trim();
                if (!speakerName) return;
                
                setIsSaving(true);
                try {
                    const formData = new FormData();
                    formData.append('file', audioBlob, 'recording.webm');
                    formData.append('name', speakerName);
                    formData.append('start', namingSegment.start.toString());
                    formData.append('end', namingSegment.end.toString());
                    
                    const response = await fetch('/v1/speakers/from-segment', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to save speaker');
                    }
                    
                    const result = await response.json();
                    console.log('Speaker saved:', result);
                    
                    // Update the segment with the new speaker name
                    setSegments(prev => prev.map(seg => 
                        seg.start === namingSegment.start && seg.end === namingSegment.end
                            ? { ...seg, speaker: speakerName }
                            : seg
                    ));
                    
                    // Update known speakers list
                    if (!knownSpeakers.includes(speakerName)) {
                        setKnownSpeakers(prev => [...prev, speakerName]);
                    }
                    
                    // Update speaker color map
                    getSpeakerColor(speakerName, speakerMap);
                    
                    closeNamingModal();
                } catch (error) {
                    console.error('Error saving speaker:', error);
                    alert('Error saving speaker: ' + error.message);
                } finally {
                    setIsSaving(false);
                }
            }, [namingSegment, audioBlob, selectedExistingSpeaker, newSpeakerName, knownSpeakers, speakerMap, closeNamingModal]);

            const reprocessAudio = useCallback(async () => {
                if (!audioBlob || processingRef.current) return;
                
                setStatus('processing');
                setStatusText('Reprocessing with updated speaker database...');
                
                // Clear segments to show fresh results
                await processStreamingDiarization(audioBlob, false);
            }, [audioBlob, processStreamingDiarization]);

            return (
                <div className="container">
                    <h1>üé§ VectorMe Voice Recorder</h1>
                    
                    <div className="card">
                        <div className={`status ${status}`}>
                            {status === 'recording' && (
                                <span className="live-indicator">
                                    <span className="live-dot"></span>
                                </span>
                            )}
                            {statusText}
                        </div>

                        <div className="waveform-container" ref={waveformRef}>
                            {isRecording ? (
                                <canvas 
                                    ref={canvasRef} 
                                    width={800} 
                                    height={50}
                                    style={{ width: '100%', height: '50px', borderRadius: '8px' }}
                                />
                            ) : !audioBlob ? (
                                <div style={{ 
                                    height: '50px', 
                                    display: 'flex', 
                                    alignItems: 'center', 
                                    justifyContent: 'center',
                                    color: '#666'
                                }}>
                                    Click Record to start
                                </div>
                            ) : null}
                        </div>

                        <div className="controls">
                            {!isRecording ? (
                                <button 
                                    className="btn-record" 
                                    onClick={startRecording}
                                    disabled={status === 'processing'}
                                >
                                    üéôÔ∏è Record
                                </button>
                            ) : (
                                <button 
                                    className="btn-stop recording" 
                                    onClick={stopRecording}
                                >
                                    ‚èπÔ∏è Stop
                                </button>
                            )}
                        </div>
                    </div>

                    {audioBlob && (
                        <div className="card">
                            <h3>üìº Recorded Audio</h3>
                            <div className="waveform-container" ref={playbackWaveformRef}></div>
                            <div className="controls">
                                <button 
                                    className="btn-play" 
                                    onClick={togglePlayback}
                                    disabled={!playbackWavesurferRef.current}
                                >
                                    {isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play'}
                                </button>
                            </div>
                        </div>
                    )}

                    {segments.length > 0 && (
                        <div className="card">
                            <div className="card-header">
                                <h3>üéØ Speaker Diarization</h3>
                                {audioBlob && (
                                    <button 
                                        className="btn-reprocess" 
                                        onClick={reprocessAudio}
                                        disabled={status === 'processing' || isRecording}
                                        title="Re-analyze audio with updated speaker database"
                                    >
                                        üîÑ Reprocess
                                    </button>
                                )}
                            </div>
                            
                            {speakers.length > 0 && (
                                <div className="speaker-list">
                                    <span style={{ color: '#888', marginRight: '8px' }}>Known speakers:</span>
                                    {speakers.map((speaker, i) => (
                                        <span 
                                            key={speaker} 
                                            className="speaker-badge"
                                            style={{ background: getSpeakerColor(speaker, speakerMap) }}
                                        >
                                            {speaker}
                                        </span>
                                    ))}
                                </div>
                            )}

                            {duration > 0 && (
                                <>
                                <div className="timeline">
                                    {segments.map((seg, i) => {
                                        const left = (seg.start / duration) * 100;
                                        const width = ((seg.end - seg.start) / duration) * 100;
                                        const isActive = activeSegment && activeSegment.start === seg.start && activeSegment.end === seg.end;
                                        return (
                                            <div
                                                key={i}
                                                className={`timeline-segment ${isActive ? 'active' : ''}`}
                                                onClick={() => seekToSegment(seg)}
                                                style={{
                                                    left: `${left}%`,
                                                    width: `${width}%`,
                                                    background: getSpeakerColor(seg.speaker, speakerMap),
                                                    cursor: audioBlob ? 'pointer' : 'default'
                                                }}
                                                title={`${seg.speaker || 'Unknown'}: ${formatTime(seg.start)} - ${formatTime(seg.end)}${audioBlob ? ' (click to play)' : ''}`}
                                            >
                                                {width > 10 ? (seg.speaker || '?') : ''}
                                            </div>
                                        );
                                    })}
                                </div>
                                {activeSegment && (
                                    <div className="timeline-info">
                                        <div className="timeline-info-item">
                                            <span className="timeline-info-label">Speaker:</span>
                                            <span className="timeline-info-value" style={{ color: getSpeakerColor(activeSegment.speaker, speakerMap) }}>
                                                {activeSegment.speaker || 'Unknown'}
                                            </span>
                                        </div>
                                        <div className="timeline-info-item">
                                            <span className="timeline-info-label">Start:</span>
                                            <span className="timeline-info-value">{formatTime(activeSegment.start)}</span>
                                        </div>
                                        <div className="timeline-info-item">
                                            <span className="timeline-info-label">Duration:</span>
                                            <span className="timeline-info-value">{(activeSegment.end - activeSegment.start).toFixed(1)}s</span>
                                        </div>
                                        <div className="timeline-info-item">
                                            <span className="timeline-info-label">End:</span>
                                            <span className="timeline-info-value">{formatTime(activeSegment.end)}</span>
                                        </div>
                                        <button 
                                            onClick={clearActiveSegment}
                                            style={{ 
                                                background: 'transparent', 
                                                border: 'none', 
                                                color: '#888', 
                                                cursor: 'pointer',
                                                padding: '0 4px',
                                                fontSize: '16px'
                                            }}
                                            title="Clear selection"
                                        >‚úï</button>
                                    </div>
                                )}
                                </>
                            )}

                            <div className="diarization-results">
                                {segments.map((seg, i) => {
                                    const isActive = activeSegment && activeSegment.start === seg.start && activeSegment.end === seg.end;
                                    return (
                                    <div 
                                        key={i} 
                                        className={`segment ${isActive ? 'active' : ''}`}
                                        onClick={() => seekToSegment(seg)}
                                        style={{ cursor: audioBlob ? 'pointer' : 'default' }}
                                        title={audioBlob ? 'Click to play from this segment' : 'Record audio to enable playback'}
                                    >
                                        <span className="segment-time">
                                            {formatTime(seg.start)} ‚Üí {formatTime(seg.end)}
                                        </span>
                                        <span 
                                            className={`segment-speaker ${seg.speaker ? 'known' : 'unknown'}`}
                                            style={seg.speaker ? { background: getSpeakerColor(seg.speaker, speakerMap) } : {}}
                                        >
                                            {seg.speaker || 'Unknown Speaker'}
                                        </span>
                                        {audioBlob && <span className="segment-play-icon">{isActive ? '‚è∏' : '‚ñ∂'}</span>}
                                        {audioBlob && (
                                            <button 
                                                className="segment-name-btn"
                                                onClick={(e) => openNamingModal(seg, e)}
                                                title="Name this speaker"
                                            >
                                                ‚úèÔ∏è Name
                                            </button>
                                        )}
                                    </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    {namingSegment && (
                        <div className="modal-overlay" onClick={closeNamingModal}>
                            <div className="modal-content" onClick={e => e.stopPropagation()}>
                                <div className="modal-title">üè∑Ô∏è Name This Speaker</div>
                                
                                <div className="modal-info" style={{ marginBottom: '16px' }}>
                                    Segment: {formatTime(namingSegment.start)} ‚Üí {formatTime(namingSegment.end)}
                                    {namingSegment.speaker && ` (currently: ${namingSegment.speaker})`}
                                </div>

                                {knownSpeakers.length > 0 && (
                                    <div className="modal-section">
                                        <div className="modal-section-title">Add to existing speaker</div>
                                        <div className="modal-speakers">
                                            {knownSpeakers.map(speaker => (
                                                <div
                                                    key={speaker}
                                                    className={`modal-speaker-option ${selectedExistingSpeaker === speaker ? 'selected' : ''}`}
                                                    style={{ background: getSpeakerColor(speaker, speakerMap) }}
                                                    onClick={() => {
                                                        setSelectedExistingSpeaker(speaker);
                                                        setNewSpeakerName('');
                                                    }}
                                                >
                                                    {speaker}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                <div className="modal-section">
                                    <div className="modal-section-title">
                                        {knownSpeakers.length > 0 ? 'Or create new speaker' : 'Create new speaker'}
                                    </div>
                                    <input
                                        type="text"
                                        className="modal-input"
                                        placeholder="Enter speaker name..."
                                        value={newSpeakerName}
                                        onChange={(e) => {
                                            setNewSpeakerName(e.target.value);
                                            setSelectedExistingSpeaker(null);
                                        }}
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter' && (newSpeakerName.trim() || selectedExistingSpeaker)) {
                                                saveSegmentSpeaker();
                                            }
                                        }}
                                        autoFocus
                                    />
                                </div>

                                <div className="modal-buttons">
                                    <button className="modal-btn modal-btn-cancel" onClick={closeNamingModal}>
                                        Cancel
                                    </button>
                                    <button 
                                        className="modal-btn modal-btn-save" 
                                        onClick={saveSegmentSpeaker}
                                        disabled={isSaving || (!newSpeakerName.trim() && !selectedExistingSpeaker)}
                                    >
                                        {isSaving ? 'Saving...' : 'Save Speaker'}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {events.length > 0 && (
                        <div className="card">
                            <h3>üìã Events Log</h3>
                            <div className="events-log">
                                {events.map((evt, i) => (
                                    <div key={i} className="event-item">
                                        <span className="event-type">[{evt.event}]</span>{' '}
                                        {JSON.stringify(evt)}
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<VoiceRecorder />);
    </script>
</body>
</html>
