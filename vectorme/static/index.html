<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VectorMe - Voice Recording & Speaker Diarization</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/record.esm.js" type="module"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .waveform-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 16px;
            min-height: 70px;
        }
        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-record {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
            color: white;
        }
        .btn-record:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(255, 65, 108, 0.4);
        }
        .btn-record.recording {
            animation: pulse 1.5s infinite;
        }
        .btn-stop {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        .btn-stop:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }
        .btn-play {
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white;
        }
        .btn-play:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(56, 239, 125, 0.4);
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 65, 108, 0.7); }
            50% { box-shadow: 0 0 0 15px rgba(255, 65, 108, 0); }
        }
        .status {
            text-align: center;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        .status.recording {
            background: rgba(255, 65, 108, 0.2);
            color: #ff6b8a;
        }
        .status.processing {
            background: rgba(102, 126, 234, 0.2);
            color: #a0b0ff;
        }
        .status.ready {
            background: rgba(56, 239, 125, 0.2);
            color: #6bffb3;
        }
        .diarization-results {
            margin-top: 20px;
        }
        .diarization-results h3 {
            margin-bottom: 16px;
            color: #a0b0ff;
        }
        .segment {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }
        .segment:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .segment-time {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            color: #888;
            min-width: 120px;
        }
        .segment-speaker {
            flex: 1;
            font-weight: 600;
            padding: 4px 12px;
            border-radius: 4px;
            display: inline-block;
        }
        .segment-speaker.unknown {
            background: rgba(255, 255, 255, 0.1);
            color: #999;
        }
        .segment-speaker.known {
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            color: white;
            box-shadow: 0 0 8px rgba(0, 210, 255, 0.5), 0 0 16px rgba(58, 123, 213, 0.3);
            animation: speakerGlow 2s ease-in-out infinite alternate;
        }
        @keyframes speakerGlow {
            from { box-shadow: 0 0 8px rgba(0, 210, 255, 0.4), 0 0 16px rgba(58, 123, 213, 0.2); }
            to { box-shadow: 0 0 12px rgba(0, 210, 255, 0.6), 0 0 24px rgba(58, 123, 213, 0.4); }
        }
        .segment-similarity {
            font-size: 14px;
            color: #666;
            margin-left: 12px;
        }
        .segment-vad-confidence {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            color: #666;
            margin-left: 8px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
        }
        .segment-vad-confidence.high {
            color: #38ef7d;
            background: rgba(56, 239, 125, 0.1);
        }
        .segment-vad-confidence.medium {
            color: #ffd200;
            background: rgba(255, 210, 0, 0.1);
        }
        .segment-vad-confidence.low {
            color: #ff6b8a;
            background: rgba(255, 107, 138, 0.1);
        }
        .timeline {
            position: relative;
            height: 40px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 20px;
            overflow: hidden;
        }
        .timeline-segment {
            position: absolute;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            white-space: nowrap;
        }
        .speaker-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }
        .speaker-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.15), 0 0 16px rgba(255, 255, 255, 0.1);
            transition: box-shadow 0.3s ease;
        }
        .speaker-badge:hover {
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.25), 0 0 24px rgba(255, 255, 255, 0.15);
        }
        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .live-dot {
            width: 8px;
            height: 8px;
            background: #ff4b2b;
            border-radius: 50%;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .events-log {
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
        }
        .event-item {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        .event-item:last-child {
            border-bottom: none;
        }
        .event-type {
            color: #00d2ff;
        }
        .segment-play-icon {
            color: #4a9eff;
            font-size: 12px;
            margin-left: auto;
            opacity: 0.5;
            transition: opacity 0.2s ease;
        }
        .segment:hover .segment-play-icon {
            opacity: 1;
        }
        .segment-name-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #a0b0ff;
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.2s ease;
        }
        .segment-name-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            min-width: 320px;
            max-width: 90vw;
        }
        .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #fff;
        }
        .modal-section {
            margin-bottom: 16px;
        }
        .modal-section-title {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .modal-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 14px;
        }
        .modal-input:focus {
            outline: none;
            border-color: #4a9eff;
        }
        .modal-speakers {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .modal-speaker-option {
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }
        .modal-speaker-option:hover {
            transform: scale(1.05);
        }
        .modal-speaker-option.selected {
            border-color: #fff;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.3);
        }
        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .modal-btn-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }
        .modal-btn-cancel:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }
        .modal-btn-save {
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            color: white;
        }
        .modal-btn-save:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(0, 210, 255, 0.4);
        }
        .modal-btn-save:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .modal-info {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
        }
        .btn-reprocess {
            background: linear-gradient(135deg, #f7971e, #ffd200);
            color: #1a1a2e;
            padding: 8px 16px;
            font-size: 13px;
        }
        .btn-reprocess:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(247, 151, 30, 0.4);
        }
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        .card-header h3 {
            margin: 0;
        }
        .segment.active {
            background: rgba(74, 158, 255, 0.2);
            border: 1px solid rgba(74, 158, 255, 0.5);
        }
        .timeline-segment.active {
            box-shadow: 0 0 0 2px #fff, 0 0 10px rgba(74, 158, 255, 0.8);
            z-index: 10;
        }
        .timeline-info {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            padding: 8px 12px;
            background: rgba(74, 158, 255, 0.1);
            border-radius: 6px;
            font-size: 13px;
        }
        .timeline-info-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .timeline-info-label {
            color: #888;
        }
        .timeline-info-value {
            color: #4a9eff;
            font-weight: 600;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        /* Mobile-friendly responsive styles */
        @media (max-width: 768px) {
            body {
                padding: 12px;
            }
            h1 {
                font-size: 1.5rem;
                margin-bottom: 16px;
            }
            .card {
                padding: 16px;
                margin-bottom: 12px;
                border-radius: 12px;
            }
            .waveform-container {
                padding: 12px;
                min-height: 60px;
                margin-bottom: 12px;
            }
            button {
                padding: 10px 18px;
                font-size: 14px;
            }
            .status {
                padding: 8px;
                margin-bottom: 12px;
                font-size: 14px;
            }
            .segment {
                padding: 10px 12px;
                flex-wrap: wrap;
                gap: 8px;
            }
            .segment-time {
                font-size: 12px;
                min-width: auto;
            }
            .segment-speaker {
                padding: 3px 10px;
                font-size: 13px;
            }
            .timeline {
                height: 32px;
            }
            .timeline-segment {
                font-size: 10px;
            }
            .speaker-list {
                gap: 6px;
            }
            .speaker-badge {
                padding: 4px 10px;
                font-size: 12px;
            }
            .events-log {
                font-size: 10px;
                padding: 8px;
                max-height: 150px;
            }
            .timeline-info {
                flex-direction: column;
                gap: 4px;
                font-size: 11px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 8px;
            }
            h1 {
                font-size: 1.25rem;
                margin-bottom: 12px;
            }
            .card {
                padding: 12px;
                margin-bottom: 10px;
            }
            .waveform-container {
                padding: 8px;
                min-height: 50px;
                margin-bottom: 10px;
            }
            .segment-time {
                width: 100%;
                margin-bottom: 4px;
            }
            .segment-speaker {
                flex: none;
            }
        }

        /* Saved Recordings Styles */
        .recordings-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .recording-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: all 0.2s ease;
            gap: 12px;
        }
        .recording-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .recording-icon {
            font-size: 24px;
            opacity: 0.7;
        }
        .recording-info {
            flex: 1;
            min-width: 0;
        }
        .recording-name {
            font-weight: 600;
            font-size: 14px;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .recording-meta {
            font-size: 12px;
            color: #888;
            display: flex;
            gap: 12px;
            margin-top: 4px;
        }
        .recording-actions {
            display: flex;
            gap: 8px;
        }
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .btn-load {
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white;
        }
        .btn-load:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 10px rgba(56, 239, 125, 0.3);
        }
        .btn-delete {
            background: rgba(255, 65, 108, 0.2);
            color: #ff6b8a;
        }
        .btn-delete:hover {
            background: rgba(255, 65, 108, 0.4);
        }
        .btn-save {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        .btn-save:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }
        .btn-share {
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            color: white;
        }
        .btn-share:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(0, 210, 255, 0.4);
        }
        .empty-state {
            text-align: center;
            padding: 24px;
            color: #666;
            font-size: 14px;
        }
        .save-recording-form {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .save-recording-form input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 14px;
        }
        .save-recording-form input:focus {
            outline: none;
            border-color: #4a9eff;
        }
        .card-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        .card-title-row h3 {
            margin: 0;
        }
        .btn-refresh {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        .btn-refresh:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Speaker colors for timeline
        const SPEAKER_COLORS = [
            '#ff416c', '#667eea', '#11998e', '#f7971e', '#8e44ad',
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'
        ];

        function getSpeakerColor(speaker, speakerMap) {
            if (!speaker || speaker.startsWith('unknown_')) return 'rgba(128, 128, 128, 0.5)';
            if (!speakerMap.has(speaker)) {
                speakerMap.set(speaker, SPEAKER_COLORS[speakerMap.size % SPEAKER_COLORS.length]);
            }
            return speakerMap.get(speaker);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(1);
            return `${mins}:${secs.padStart(4, '0')}`;
        }

        function VoiceRecorder() {
            const [isRecording, setIsRecording] = useState(false);
            const [isPaused, setIsPaused] = useState(false);
            const [isPlaying, setIsPlaying] = useState(false);
            const [status, setStatus] = useState('ready');
            const [statusText, setStatusText] = useState('Ready to record');
            const [audioBlob, setAudioBlob] = useState(null);
            const [duration, setDuration] = useState(0);
            const [segments, setSegments] = useState([]);
            const [events, setEvents] = useState([]);
            const [speakers, setSpeakers] = useState([]);
            const [speakerMap] = useState(new Map());
            const [activeSegment, setActiveSegment] = useState(null);
            const [namingSegment, setNamingSegment] = useState(null);
            const [newSpeakerName, setNewSpeakerName] = useState('');
            const [selectedExistingSpeaker, setSelectedExistingSpeaker] = useState(null);
            const [isSaving, setIsSaving] = useState(false);
            const [knownSpeakers, setKnownSpeakers] = useState([]);
            
            // Diarization mode state
            const [diarizationMode, setDiarizationMode] = useState('fast'); // 'fast' or 'accurate'
            const [refinedSegments, setRefinedSegments] = useState([]); // TS-VAD refined segments
            const [unknownSpeakers, setUnknownSpeakers] = useState([]); // unknown speaker clusters from TS-VAD
            
            // Saved recordings state
            const [savedRecordings, setSavedRecordings] = useState([]);
            const [recordingName, setRecordingName] = useState('');
            const [currentRecordingId, setCurrentRecordingId] = useState(null);
            const [currentTime, setCurrentTime] = useState(0);
            const [selection, setSelection] = useState(null); // {start, end} for drag selection
            const [isSavingRecording, setIsSavingRecording] = useState(false);
            const [isLoadingRecording, setIsLoadingRecording] = useState(false);
            
            // Speaker comparison state
            const [compareSpeaker, setCompareSpeaker] = useState(null);
            const [segmentSimilarities, setSegmentSimilarities] = useState({}); // {"start-end": similarity}
            const [identifyingSegment, setIdentifyingSegment] = useState(null); // segment being identified
            const [segmentIdentifications, setSegmentIdentifications] = useState({}); // {"start-end": {matches, top_match}}

            const waveformRef = useRef(null);
            const playbackWaveformRef = useRef(null);
            const wavesurferRef = useRef(null);
            const playbackWavesurferRef = useRef(null);
            const regionsRef = useRef(null);
            const selectionRef = useRef(null);
            const mediaRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);
            const streamRef = useRef(null);
            const processingRef = useRef(false);
            const lastProcessedChunkRef = useRef(0);
            const activeSegmentRef = useRef(null);
            const canvasRef = useRef(null);
            const audioContextRef = useRef(null);
            const analyserRef = useRef(null);
            const animationRef = useRef(null);

            // Initialize recording waveform
            useEffect(() => {
                if (waveformRef.current && !wavesurferRef.current) {
                    wavesurferRef.current = WaveSurfer.create({
                        container: waveformRef.current,
                        waveColor: '#4a9eff',
                        progressColor: '#00d2ff',
                        cursorColor: '#fff',
                        barWidth: 2,
                        barGap: 1,
                        barRadius: 2,
                        height: 50,
                        normalize: true,
                    });
                }

                return () => {
                    if (wavesurferRef.current) {
                        wavesurferRef.current.destroy();
                        wavesurferRef.current = null;
                    }
                };
            }, []);

            // Initialize playback waveform when audio is available
            useEffect(() => {
                if (playbackWaveformRef.current && audioBlob && !playbackWavesurferRef.current) {
                    // Create regions plugin for drag selection
                    const regions = WaveSurfer.Regions.create();
                    regionsRef.current = regions;

                    playbackWavesurferRef.current = WaveSurfer.create({
                        container: playbackWaveformRef.current,
                        waveColor: '#4a9eff',
                        progressColor: '#00d2ff',
                        cursorColor: '#fff',
                        barWidth: 2,
                        barGap: 1,
                        barRadius: 2,
                        height: 50,
                        normalize: true,
                        plugins: [regions],
                    });

                    // Enable drag selection to create regions
                    regions.enableDragSelection({
                        color: 'rgba(0, 210, 255, 0.3)',
                    });

                    // When a region is created or updated
                    regions.on('region-created', (region) => {
                        // Remove any existing regions first (only allow one selection)
                        regions.getRegions().forEach(r => {
                            if (r.id !== region.id) r.remove();
                        });
                        const sel = { start: region.start, end: region.end };
                        setSelection(sel);
                        selectionRef.current = sel;
                    });

                    regions.on('region-updated', (region) => {
                        const sel = { start: region.start, end: region.end };
                        setSelection(sel);
                        selectionRef.current = sel;
                    });

                    // Double-click on region to play it
                    regions.on('region-double-clicked', (region) => {
                        region.play();
                    });

                    const url = URL.createObjectURL(audioBlob);
                    playbackWavesurferRef.current.load(url);

                    // Double-click on waveform (outside region) clears selection
                    playbackWavesurferRef.current.on('dblclick', () => {
                        if (regionsRef.current) {
                            regionsRef.current.clearRegions();
                        }
                        setSelection(null);
                        selectionRef.current = null;
                    });

                    playbackWavesurferRef.current.on('finish', () => {
                        setIsPlaying(false);
                    });

                    playbackWavesurferRef.current.on('play', () => {
                        setIsPlaying(true);
                    });

                    playbackWavesurferRef.current.on('pause', () => {
                        setIsPlaying(false);
                    });

                    // Listen for timeupdate to track position and stop at segment/selection end
                    playbackWavesurferRef.current.on('timeupdate', (time) => {
                        setCurrentTime(time);
                        // Stop at segment end if playing a segment
                        if (activeSegmentRef.current && time >= activeSegmentRef.current.end) {
                            playbackWavesurferRef.current.pause();
                            setActiveSegment(null);
                            activeSegmentRef.current = null;
                        }
                        // Stop at selection end if playing within a selection
                        if (selectionRef.current && time >= selectionRef.current.end) {
                            playbackWavesurferRef.current.pause();
                            // Seek back to selection start for next play
                            const position = selectionRef.current.start / playbackWavesurferRef.current.getDuration();
                            playbackWavesurferRef.current.seekTo(position);
                        }
                    });
                }

                return () => {
                    if (playbackWavesurferRef.current) {
                        playbackWavesurferRef.current.destroy();
                        playbackWavesurferRef.current = null;
                        regionsRef.current = null;
                        setSelection(null);
                        selectionRef.current = null;
                    }
                };
            }, [audioBlob]);

            const startRecording = useCallback(async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            channelCount: 1,
                            sampleRate: 16000,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    streamRef.current = stream;

                    // Clear previous state
                    audioChunksRef.current = [];
                    lastProcessedChunkRef.current = 0;
                    processingRef.current = false;
                    setSegments([]);
                    setRefinedSegments([]);
                    setUnknownSpeakers([]);
                    setEvents([]);
                    setSpeakers([]);
                    speakerMap.clear();
                    setActiveSegment(null);
                    activeSegmentRef.current = null;
                    setCurrentRecordingId(null);
                    
                    // Reset URL to home
                    if (window.location.pathname !== '/') {
                        window.history.pushState({}, '', '/');
                    }

                    // Cleanup previous playback wavesurfer
                    if (playbackWavesurferRef.current) {
                        playbackWavesurferRef.current.destroy();
                        playbackWavesurferRef.current = null;
                    }
                    setAudioBlob(null);

                    // Create MediaRecorder
                    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                        ? 'audio/webm;codecs=opus' 
                        : 'audio/webm';
                    
                    mediaRecorderRef.current = new MediaRecorder(stream, { mimeType });

                    mediaRecorderRef.current.ondataavailable = async (event) => {
                        if (event.data.size > 0) {
                            audioChunksRef.current.push(event.data);
                            
                            // Stream to backend every 3 chunks (3 seconds) for real-time results
                            if (audioChunksRef.current.length >= 3 && 
                                audioChunksRef.current.length % 2 === 0 &&
                                !processingRef.current) {
                                const blob = new Blob(audioChunksRef.current, { type: mimeType });
                                // Process in background, don't await
                                processStreamingDiarization(blob, true);
                            }
                        }
                    };

                    mediaRecorderRef.current.onstop = async () => {
                        const blob = new Blob(audioChunksRef.current, { type: mimeType });
                        setAudioBlob(blob);
                        
                        // Final diarization with complete audio
                        await processStreamingDiarization(blob, false);
                        
                        // Run TS-VAD refinement if accurate mode is selected
                        if (diarizationMode === 'accurate') {
                            await processRefinedDiarization(blob);
                        }
                    };

                    // Start recording with timeslice for streaming (1 second chunks)
                    mediaRecorderRef.current.start(1000);
                    setIsRecording(true);
                    setIsPaused(false);
                    setStatus('recording');
                    setStatusText('Recording... Results will appear in real-time');

                    // Start live visualization using AudioContext
                    const audioContext = new AudioContext();
                    audioContextRef.current = audioContext;
                    const source = audioContext.createMediaStreamSource(stream);
                    const analyser = audioContext.createAnalyser();
                    analyserRef.current = analyser;
                    analyser.fftSize = 2048;
                    source.connect(analyser);

                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);

                    const drawWaveform = () => {
                        if (mediaRecorderRef.current?.state !== 'recording') {
                            animationRef.current = null;
                            return;
                        }
                        
                        animationRef.current = requestAnimationFrame(drawWaveform);
                        
                        const canvas = canvasRef.current;
                        if (!canvas) return;
                        
                        const ctx = canvas.getContext('2d');
                        const width = canvas.width;
                        const height = canvas.height;
                        
                        analyser.getByteTimeDomainData(dataArray);
                        
                        // Clear canvas
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.fillRect(0, 0, width, height);
                        
                        // Draw waveform
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = '#4a9eff';
                        ctx.beginPath();
                        
                        const sliceWidth = width / bufferLength;
                        let x = 0;
                        
                        for (let i = 0; i < bufferLength; i++) {
                            const v = dataArray[i] / 128.0;
                            const y = (v * height) / 2;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                            x += sliceWidth;
                        }
                        
                        ctx.lineTo(width, height / 2);
                        ctx.stroke();
                        
                        // Draw center line
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, height / 2);
                        ctx.lineTo(width, height / 2);
                        ctx.stroke();
                        
                        // Add glow effect based on intensity
                        const average = dataArray.reduce((a, b) => a + Math.abs(b - 128), 0) / bufferLength;
                        const intensity = Math.min(average / 50, 1);
                        waveformRef.current.style.boxShadow = `inset 0 0 ${20 + intensity * 30}px rgba(74, 158, 255, ${intensity * 0.5})`;
                    };
                    
                    drawWaveform();

                } catch (error) {
                    console.error('Error starting recording:', error);
                    setStatus('ready');
                    setStatusText('Error: Could not access microphone');
                }
            }, [speakerMap, processStreamingDiarization, processRefinedDiarization, diarizationMode]);

            const stopRecording = useCallback(() => {
                if (mediaRecorderRef.current && (mediaRecorderRef.current.state === 'recording' || mediaRecorderRef.current.state === 'paused')) {
                    mediaRecorderRef.current.stop();
                }
                if (streamRef.current) {
                    streamRef.current.getTracks().forEach(track => track.stop());
                    streamRef.current = null;
                }
                // Cancel animation frame
                if (animationRef.current) {
                    cancelAnimationFrame(animationRef.current);
                    animationRef.current = null;
                }
                // Close audio context
                if (audioContextRef.current) {
                    audioContextRef.current.close();
                    audioContextRef.current = null;
                }
                setIsRecording(false);
                setIsPaused(false);
                setStatus('processing');
                setStatusText('Finalizing analysis...');
                
                // Reset waveform glow
                if (waveformRef.current) {
                    waveformRef.current.style.boxShadow = 'none';
                }
            }, []);

            const pauseRecording = useCallback(() => {
                if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                    mediaRecorderRef.current.pause();
                    setIsPaused(true);
                    setStatusText('Recording paused');
                }
            }, []);

            const resumeRecording = useCallback(() => {
                if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'paused') {
                    mediaRecorderRef.current.resume();
                    setIsPaused(false);
                    setStatusText('Recording... Results will appear in real-time');
                }
            }, []);

            const processStreamingDiarization = useCallback(async (blob, isPartial = false) => {
                if (processingRef.current) return;
                processingRef.current = true;

                try {
                    const formData = new FormData();
                    formData.append('file', blob, 'recording.webm');
                    formData.append('response_format', 'diarized_json');
                    formData.append('stream', 'true');
                    formData.append('vad', 'true');
                    formData.append('chunk_size', '2.0');
                    formData.append('chunk_hop', '0.5');

                    const response = await fetch('/v1/audio/transcriptions', {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';

                    // Collect all segments and events from this response before updating state
                    const newSegments = [];
                    const newEvents = [];
                    let newDuration = duration;
                    let newSpeakers = speakers;

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            if (line.trim()) {
                                try {
                                    const event = JSON.parse(line);
                                    newEvents.push(event);
                                    
                                    // Process event data locally
                                    switch (event.event) {
                                        case 'start':
                                            newDuration = event.duration;
                                            newSpeakers = event.speakers || [];
                                            break;
                                        case 'segment':
                                            newSegments.push({
                                                start: event.start,
                                                end: event.end,
                                                speaker: event.speaker,
                                                vad_confidence: event.vad_confidence
                                            });
                                            break;
                                    }
                                } catch (e) {
                                    console.error('Error parsing event:', e);
                                }
                            }
                        }
                    }

                    // Batch update state once after all data is collected (prevents flicker)
                    if (isPartial) {
                        // For partial updates, replace all segments at once
                        setSegments(newSegments);
                        setEvents(newEvents);
                    } else {
                        // For final update, replace everything
                        setSegments(newSegments);
                        setEvents(newEvents);
                    }
                    setDuration(newDuration);
                    setSpeakers(newSpeakers);

                    if (!isPartial) {
                        setStatus('ready');
                        setStatusText('Recording complete - Click play to listen');
                    }

                } catch (error) {
                    console.error('Error processing diarization:', error);
                    if (!isPartial) {
                        setStatus('ready');
                        setStatusText('Error processing audio');
                    }
                } finally {
                    processingRef.current = false;
                }
            }, [duration, speakers]);

            const processRefinedDiarization = useCallback(async (blob) => {
                try {
                    setStatus('processing');
                    setStatusText('Running TS-VAD refinement...');

                    const formData = new FormData();
                    formData.append('file', blob, 'recording.webm');
                    formData.append('response_format', 'diarized_json');
                    formData.append('stream', 'false');
                    formData.append('diarization_mode', 'ts_vad');

                    const response = await fetch('/v1/audio/transcriptions', {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();

                    // Update refined segments and unknown speakers
                    setRefinedSegments(result.segments || []);
                    setUnknownSpeakers(result.unknown_speakers || []);
                    setKnownSpeakers(prev => {
                        const newKnown = result.known_speakers || [];
                        const merged = [...new Set([...prev, ...newKnown])];
                        return merged;
                    });

                    setStatus('ready');
                    setStatusText('TS-VAD refinement complete');

                } catch (error) {
                    console.error('Error processing TS-VAD refinement:', error);
                    setStatus('ready');
                    setStatusText('Error in TS-VAD refinement');
                }
            }, []);

            const togglePlayback = useCallback(() => {
                if (playbackWavesurferRef.current) {
                    if (playbackWavesurferRef.current.isPlaying()) {
                        playbackWavesurferRef.current.pause();
                    } else {
                        // If there's a selection, play from selection start
                        if (selectionRef.current) {
                            const currentTime = playbackWavesurferRef.current.getCurrentTime();
                            // If cursor is outside selection, seek to selection start
                            if (currentTime < selectionRef.current.start || currentTime >= selectionRef.current.end) {
                                const position = selectionRef.current.start / playbackWavesurferRef.current.getDuration();
                                playbackWavesurferRef.current.seekTo(position);
                            }
                        }
                        playbackWavesurferRef.current.play();
                    }
                }
            }, []);

            // Keyboard shortcut for spacebar to toggle playback
            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Only trigger if not typing in an input field
                    if (e.code === 'Space' && 
                        e.target.tagName !== 'INPUT' && 
                        e.target.tagName !== 'TEXTAREA' &&
                        playbackWavesurferRef.current &&
                        audioBlob) {
                        e.preventDefault();
                        if (playbackWavesurferRef.current.isPlaying()) {
                            playbackWavesurferRef.current.pause();
                        } else {
                            // If there's a selection, play from selection start
                            if (selectionRef.current) {
                                const currentTime = playbackWavesurferRef.current.getCurrentTime();
                                // If cursor is outside selection, seek to selection start
                                if (currentTime < selectionRef.current.start || currentTime >= selectionRef.current.end) {
                                    const position = selectionRef.current.start / playbackWavesurferRef.current.getDuration();
                                    playbackWavesurferRef.current.seekTo(position);
                                }
                            }
                            playbackWavesurferRef.current.play();
                        }
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [audioBlob]);

            const seekToSegment = useCallback((segment) => {
                if (playbackWavesurferRef.current && duration > 0) {
                    // Set active segment for tracking
                    setActiveSegment(segment);
                    activeSegmentRef.current = segment;
                    
                    // Clear existing regions and create a new one for this segment
                    if (regionsRef.current) {
                        regionsRef.current.clearRegions();
                        regionsRef.current.addRegion({
                            start: segment.start,
                            end: segment.end,
                            color: 'rgba(0, 210, 255, 0.3)',
                        });
                        const sel = { start: segment.start, end: segment.end };
                        setSelection(sel);
                        selectionRef.current = sel;
                    }
                    
                    // Seek to the position (0-1 range)
                    const position = segment.start / duration;
                    playbackWavesurferRef.current.seekTo(position);
                    // Start playing
                    playbackWavesurferRef.current.play();
                }
            }, [duration]);

            const clearActiveSegment = useCallback(() => {
                setActiveSegment(null);
                activeSegmentRef.current = null;
            }, []);

            // Fetch known speakers on mount
            useEffect(() => {
                fetch('/v1/speakers')
                    .then(res => res.json())
                    .then(data => setKnownSpeakers(data.speakers || []))
                    .catch(err => console.error('Error fetching speakers:', err));
            }, []);
            
            // Fetch saved recordings on mount
            const fetchRecordings = useCallback(() => {
                fetch('/v1/recordings')
                    .then(res => res.json())
                    .then(data => setSavedRecordings(data.recordings || []))
                    .catch(err => console.error('Error fetching recordings:', err));
            }, []);
            
            useEffect(() => {
                fetchRecordings();
            }, [fetchRecordings]);
            
            // URL routing: load recording from path on mount
            useEffect(() => {
                const path = window.location.pathname;
                const match = path.match(/^\/recording\/([a-zA-Z0-9_-]+)$/);
                if (match) {
                    const recordingId = match[1];
                    // Fetch recording metadata and load it
                    fetch(`/v1/recordings`)
                        .then(res => res.json())
                        .then(data => {
                            const recording = (data.recordings || []).find(r => r.id === recordingId);
                            if (recording) {
                                loadRecording(recording);
                            } else {
                                console.error('Recording not found:', recordingId);
                                // Navigate to home
                                window.history.replaceState({}, '', '/');
                            }
                        })
                        .catch(err => console.error('Error loading recording from URL:', err));
                }
            }, []); // Only run once on mount
            
            // Save current recording
            const saveRecording = useCallback(async () => {
                if (!audioBlob || isSavingRecording) return;
                
                setIsSavingRecording(true);
                try {
                    const formData = new FormData();
                    formData.append('file', audioBlob, 'recording.webm');
                    formData.append('name', recordingName.trim() || `Recording ${new Date().toLocaleString()}`);
                    formData.append('duration', duration.toString());
                    
                    const response = await fetch('/v1/recordings', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to save recording');
                    }
                    
                    const result = await response.json();
                    console.log('Recording saved:', result);
                    
                    // Refresh recordings list
                    fetchRecordings();
                    setRecordingName('');
                } catch (error) {
                    console.error('Error saving recording:', error);
                    alert('Error saving recording: ' + error.message);
                } finally {
                    setIsSavingRecording(false);
                }
            }, [audioBlob, recordingName, duration, fetchRecordings, isSavingRecording]);
            
            // Load a saved recording
            const loadRecording = useCallback(async (recording) => {
                if (isLoadingRecording || isRecording) return;
                
                setIsLoadingRecording(true);
                setStatus('processing');
                setStatusText(`Loading "${recording.name}"...`);
                setCurrentRecordingId(recording.id);
                
                // Update URL without page reload
                window.history.pushState({ recordingId: recording.id }, '', `/recording/${recording.id}`);
                
                try {
                    // Fetch the audio file
                    const response = await fetch(`/v1/recordings/${recording.id}`);
                    if (!response.ok) {
                        throw new Error('Failed to fetch recording');
                    }
                    
                    const blob = await response.blob();
                    
                    // Clear previous state
                    setSegments([]);
                    setRefinedSegments([]);
                    setUnknownSpeakers([]);
                    setEvents([]);
                    setSpeakers([]);
                    speakerMap.clear();
                    setActiveSegment(null);
                    activeSegmentRef.current = null;
                    
                    // Cleanup previous playback wavesurfer
                    if (playbackWavesurferRef.current) {
                        playbackWavesurferRef.current.destroy();
                        playbackWavesurferRef.current = null;
                    }
                    
                    // Set the audio blob (this will trigger playback waveform creation)
                    setAudioBlob(blob);
                    
                    // Process diarization
                    await processStreamingDiarization(blob, false);
                    
                    // Run TS-VAD refinement if accurate mode is selected
                    if (diarizationMode === 'accurate') {
                        await processRefinedDiarization(blob);
                    }
                    
                } catch (error) {
                    console.error('Error loading recording:', error);
                    setStatus('ready');
                    setStatusText('Error loading recording');
                } finally {
                    setIsLoadingRecording(false);
                }
            }, [isLoadingRecording, isRecording, processStreamingDiarization, processRefinedDiarization, diarizationMode, speakerMap]);
            
            // Delete a saved recording
            const deleteRecording = useCallback(async (recording, e) => {
                e.stopPropagation();
                
                if (!confirm(`Delete "${recording.name}"?`)) return;
                
                try {
                    const response = await fetch(`/v1/recordings/${recording.id}`, {
                        method: 'DELETE'
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to delete recording');
                    }
                    
                    // Refresh recordings list
                    fetchRecordings();
                } catch (error) {
                    console.error('Error deleting recording:', error);
                    alert('Error deleting recording: ' + error.message);
                }
            }, [fetchRecordings]);
            
            // Format file size
            const formatSize = (bytes) => {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            };
            
            // Format date
            const formatDate = (isoString) => {
                const date = new Date(isoString);
                return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            };

            const openNamingModal = useCallback((segment, e) => {
                e.stopPropagation();
                setNamingSegment(segment);
                setNewSpeakerName('');
                setSelectedExistingSpeaker(null);
                // Refresh speaker list
                fetch('/v1/speakers')
                    .then(res => res.json())
                    .then(data => setKnownSpeakers(data.speakers || []))
                    .catch(err => console.error('Error fetching speakers:', err));
            }, []);

            const closeNamingModal = useCallback(() => {
                setNamingSegment(null);
                setNewSpeakerName('');
                setSelectedExistingSpeaker(null);
            }, []);

            const saveSegmentSpeaker = useCallback(async () => {
                if (!namingSegment || !audioBlob) return;
                
                const speakerName = selectedExistingSpeaker || newSpeakerName.trim();
                if (!speakerName) return;
                
                setIsSaving(true);
                try {
                    const formData = new FormData();
                    formData.append('file', audioBlob, 'recording.webm');
                    formData.append('name', speakerName);
                    formData.append('start', namingSegment.start.toString());
                    formData.append('end', namingSegment.end.toString());
                    
                    const response = await fetch('/v1/speakers/from-segment', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to save speaker');
                    }
                    
                    const result = await response.json();
                    console.log('Speaker saved:', result);
                    
                    // Update ALL segments with the same speaker cluster label
                    const oldSpeakerLabel = namingSegment.speaker;
                    setSegments(prev => prev.map(seg => 
                        seg.speaker === oldSpeakerLabel
                            ? { ...seg, speaker: speakerName }
                            : seg
                    ));
                    setRefinedSegments(prev => prev.map(seg => 
                        seg.speaker === oldSpeakerLabel
                            ? { ...seg, speaker: speakerName }
                            : seg
                    ));
                    
                    // Remove from unknown speakers if it was an unknown cluster
                    if (oldSpeakerLabel && oldSpeakerLabel.startsWith('unknown_')) {
                        setUnknownSpeakers(prev => prev.filter(u => u !== oldSpeakerLabel));
                    }
                    
                    // Update known speakers list
                    if (!knownSpeakers.includes(speakerName)) {
                        setKnownSpeakers(prev => [...prev, speakerName]);
                    }
                    
                    // Update speaker color map
                    getSpeakerColor(speakerName, speakerMap);
                    
                    closeNamingModal();
                } catch (error) {
                    console.error('Error saving speaker:', error);
                    alert('Error saving speaker: ' + error.message);
                } finally {
                    setIsSaving(false);
                }
            }, [namingSegment, audioBlob, selectedExistingSpeaker, newSpeakerName, knownSpeakers, speakerMap, closeNamingModal]);

            const reprocessAudio = useCallback(async () => {
                if (!audioBlob || processingRef.current) return;
                
                setStatus('processing');
                setStatusText('Reprocessing with updated speaker database...');
                
                // Clear segments to show fresh results
                await processStreamingDiarization(audioBlob, false);
                
                // Run TS-VAD refinement if accurate mode is selected
                if (diarizationMode === 'accurate') {
                    await processRefinedDiarization(audioBlob);
                }
            }, [audioBlob, processStreamingDiarization, processRefinedDiarization, diarizationMode]);

            // Compare all segments against a specific speaker
            const compareToSpeaker = useCallback(async (speakerName) => {
                if (!audioBlob || !segments.length) return;
                
                if (compareSpeaker === speakerName) {
                    // Toggle off if clicking the same speaker
                    setCompareSpeaker(null);
                    setSegmentSimilarities({});
                    return;
                }
                
                setCompareSpeaker(speakerName);
                setSegmentSimilarities({});
                
                try {
                    const formData = new FormData();
                    formData.append('file', audioBlob, 'recording.webm');
                    formData.append('segments', JSON.stringify(segments.map(s => ({ start: s.start, end: s.end }))));
                    
                    const response = await fetch(`/v1/speakers/${encodeURIComponent(speakerName)}/compare`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to compare segments');
                    }
                    
                    const result = await response.json();
                    const similarities = {};
                    for (const seg of result.segments) {
                        const key = `${seg.start}-${seg.end}`;
                        similarities[key] = seg.similarity;
                    }
                    setSegmentSimilarities(similarities);
                } catch (error) {
                    console.error('Error comparing to speaker:', error);
                    setCompareSpeaker(null);
                }
            }, [audioBlob, segments, compareSpeaker]);

            // Identify a single segment against speaker database
            const identifySegment = useCallback(async (seg, e) => {
                e.stopPropagation();
                if (!audioBlob) return;
                
                const segKey = `${seg.start}-${seg.end}`;
                setIdentifyingSegment(segKey);
                
                try {
                    const formData = new FormData();
                    formData.append('file', audioBlob, 'recording.webm');
                    formData.append('start', seg.start.toString());
                    formData.append('end', seg.end.toString());
                    
                    const response = await fetch('/v1/speakers/identify-segment', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to identify segment');
                    }
                    
                    const result = await response.json();
                    setSegmentIdentifications(prev => ({
                        ...prev,
                        [segKey]: result
                    }));
                    
                    // If we got a top match, update the segment's speaker in both arrays
                    if (result.top_match && result.top_match.similarity >= 0.5) {
                        setSegments(prev => prev.map(s => 
                            s.start === seg.start && s.end === seg.end
                                ? { ...s, speaker: result.top_match.name }
                                : s
                        ));
                        setRefinedSegments(prev => prev.map(s => 
                            s.start === seg.start && s.end === seg.end
                                ? { ...s, speaker: result.top_match.name }
                                : s
                        ));
                        // Update speaker color
                        getSpeakerColor(result.top_match.name, speakerMap);
                    }
                } catch (error) {
                    console.error('Error identifying segment:', error);
                } finally {
                    setIdentifyingSegment(null);
                }
            }, [audioBlob, speakerMap]);

            return (
                <div className="container">
                    <h1> VectorMe Voice Recorder</h1>
                    
                    <div className="card">
                        <div className={`status ${status}`}>
                            {status === 'recording' && (
                                <span className="live-indicator">
                                    <span className="live-dot"></span>
                                </span>
                            )}
                            {statusText}
                        </div>

                        <div className="waveform-container" ref={waveformRef}>
                            {isRecording ? (
                                <canvas 
                                    ref={canvasRef} 
                                    width={800} 
                                    height={50}
                                    style={{ width: '100%', height: '50px', borderRadius: '8px' }}
                                />
                            ) : !audioBlob ? (
                                <div style={{ 
                                    height: '50px', 
                                    display: 'flex', 
                                    alignItems: 'center', 
                                    justifyContent: 'center',
                                    color: '#666'
                                }}>
                                    Click Record to start
                                </div>
                            ) : null}
                        </div>

                        <div className="controls">
                            {/* Diarization Mode Selector */}
                            <select
                                value={diarizationMode}
                                onChange={(e) => setDiarizationMode(e.target.value)}
                                disabled={isRecording}
                                style={{
                                    padding: '8px 12px',
                                    fontSize: '14px',
                                    background: 'rgba(255,255,255,0.1)',
                                    color: '#fff',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '6px',
                                    marginRight: '12px',
                                    cursor: isRecording ? 'not-allowed' : 'pointer'
                                }}
                            >
                                <option value="fast" style={{ background: '#1a1a2e' }}> Fast</option>
                                <option value="accurate" style={{ background: '#1a1a2e' }}> Accurate</option>
                            </select>
                            {!isRecording ? (
                                <button 
                                    className="btn-record" 
                                    onClick={startRecording}
                                    disabled={status === 'processing'}
                                >
                                     Record
                                </button>
                            ) : (
                                <>
                                    <button 
                                        className="btn-play" 
                                        onClick={isPaused ? resumeRecording : pauseRecording}
                                        style={{ background: isPaused ? 'linear-gradient(135deg, #11998e, #38ef7d)' : 'linear-gradient(135deg, #f7971e, #ffd200)', color: isPaused ? 'white' : '#1a1a2e' }}
                                    >
                                        {isPaused ? ' Resume' : ' Pause'}
                                    </button>
                                    <button 
                                        className="btn-stop recording" 
                                        onClick={stopRecording}
                                    >
                                         Stop
                                    </button>
                                </>
                            )}
                        </div>
                    </div>

                    {audioBlob && (
                        <div className="card">
                            <h3> Recorded Audio</h3>
                            <div className="waveform-container" ref={playbackWaveformRef}></div>
                            <div className="playback-time" style={{
                                display: 'flex',
                                justifyContent: 'space-between',
                                padding: '4px 8px',
                                fontFamily: "'Monaco', 'Consolas', monospace",
                                fontSize: '13px',
                                color: '#4a9eff',
                                marginBottom: '8px'
                            }}>
                                <span>{formatTime(currentTime)}</span>
                                <span style={{ color: '#888' }}>{selection ? `Selection: ${formatTime(selection.start)} - ${formatTime(selection.end)}` : 'Drag to select  Space to play/pause'}</span>
                                <span>{formatTime(duration)}</span>
                            </div>
                            <div className="controls">
                                <button 
                                    className="btn-play" 
                                    onClick={togglePlayback}
                                    disabled={!playbackWavesurferRef.current}
                                >
                                    {isPlaying ? ' Pause' : ' Play'}
                                </button>
                                {selection && (
                                    <button 
                                        className="btn-play" 
                                        onClick={() => {
                                            const regions = regionsRef.current?.getRegions();
                                            if (regions && regions.length > 0) {
                                                regions[0].play();
                                            }
                                        }}
                                        style={{ background: 'linear-gradient(135deg, #667eea, #764ba2)' }}
                                    >
                                         Play Selection
                                    </button>
                                )}
                                {selection && (
                                    <button 
                                        className="btn-play" 
                                        onClick={() => {
                                            regionsRef.current?.clearRegions();
                                            setSelection(null);
                                            selectionRef.current = null;
                                        }}
                                        style={{ background: 'rgba(255, 255, 255, 0.1)', color: '#888' }}
                                    >
                                         Clear
                                    </button>
                                )}
                                {selection && (
                                    <button 
                                        className="btn-play" 
                                        onClick={(e) => openNamingModal({ start: selection.start, end: selection.end }, e)}
                                        style={{ background: 'linear-gradient(135deg, #00d2ff, #3a7bd5)' }}
                                    >
                                         Name Speaker
                                    </button>
                                )}
                                {selection && (
                                    <button 
                                        className="btn-play" 
                                        onClick={(e) => identifySegment({ start: selection.start, end: selection.end }, e)}
                                        disabled={identifyingSegment === `${selection.start}-${selection.end}`}
                                        style={{ background: 'linear-gradient(135deg, #f7971e, #ffd200)', color: '#1a1a2e' }}
                                    >
                                        {identifyingSegment === `${selection.start}-${selection.end}` ? ' Identifying...' : ' Identify Speaker'}
                                    </button>
                                )}
                            </div>
                            
                            {/* Show identification results for selection */}
                            {selection && segmentIdentifications[`${selection.start}-${selection.end}`] && (
                                <div style={{
                                    marginTop: '12px',
                                    padding: '12px 16px',
                                    background: 'rgba(0, 0, 0, 0.3)',
                                    borderRadius: '8px',
                                    fontSize: '14px'
                                }}>
                                    <div style={{ marginBottom: '8px', color: '#a0b0ff', fontWeight: 600 }}>
                                         Identification Results
                                    </div>
                                    {segmentIdentifications[`${selection.start}-${selection.end}`].matches?.length > 0 ? (
                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                                            {segmentIdentifications[`${selection.start}-${selection.end}`].matches.map((match, idx) => (
                                                <span 
                                                    key={match.name}
                                                    style={{
                                                        padding: '6px 12px',
                                                        borderRadius: '16px',
                                                        background: idx === 0 ? getSpeakerColor(match.name, speakerMap) : 'rgba(255, 255, 255, 0.1)',
                                                        color: idx === 0 ? 'white' : '#888',
                                                        fontFamily: "'Monaco', 'Consolas', monospace",
                                                        fontSize: '13px',
                                                        border: idx === 0 ? '2px solid rgba(255, 255, 255, 0.5)' : 'none'
                                                    }}
                                                >
                                                    {match.name}: {(match.similarity * 100).toFixed(0)}%
                                                </span>
                                            ))}
                                        </div>
                                    ) : (
                                        <span style={{ color: '#888' }}>No matching speakers found</span>
                                    )}
                                </div>
                            )}
                            
                            {/* Save Recording Form */}
                            <div className="save-recording-form" style={{ marginTop: '16px' }}>
                                <input
                                    type="text"
                                    placeholder="Name this recording..."
                                    value={recordingName}
                                    onChange={(e) => setRecordingName(e.target.value)}
                                    onKeyDown={(e) => {
                                        if (e.key === 'Enter') saveRecording();
                                    }}
                                    aria-label="Recording name"
                                />
                                <button
                                    className="btn-save"
                                    onClick={saveRecording}
                                    disabled={isSavingRecording}
                                    title="Save recording for later analysis"
                                >
                                    {isSavingRecording ? ' Saving...' : ' Save'}
                                </button>
                                {currentRecordingId && (
                                    <button
                                        className="btn-share"
                                        onClick={() => {
                                            const url = `${window.location.origin}/recording/${currentRecordingId}`;
                                            navigator.clipboard.writeText(url).then(() => {
                                                // Show brief feedback
                                                const btn = event.target;
                                                const originalText = btn.innerText;
                                                btn.innerText = ' Copied!';
                                                setTimeout(() => btn.innerText = originalText, 2000);
                                            }).catch(err => {
                                                console.error('Failed to copy:', err);
                                                prompt('Copy this link:', url);
                                            });
                                        }}
                                        title="Copy link to this recording"
                                    >
                                         Copy Link
                                    </button>
                                )}
                            </div>
                        </div>
                    )}

                    {segments.length > 0 && (
                        <div className="card">
                            <div className="card-header">
                                <h3> Speaker Diarization</h3>
                                {audioBlob && (
                                    <button 
                                        className="btn-reprocess" 
                                        onClick={reprocessAudio}
                                        disabled={status === 'processing' || isRecording}
                                        title="Re-analyze audio with updated speaker database"
                                    >
                                         Reprocess
                                    </button>
                                )}
                            </div>
                            
                            {speakers.length > 0 && (
                                <div className="speaker-list">
                                    <span style={{ color: '#888', marginRight: '8px' }}>Compare to speaker:</span>
                                    {speakers.map((speaker, i) => (
                                        <span 
                                            key={speaker} 
                                            className="speaker-badge"
                                            onClick={() => compareToSpeaker(speaker)}
                                            style={{ 
                                                background: getSpeakerColor(speaker, speakerMap),
                                                cursor: 'pointer',
                                                border: compareSpeaker === speaker ? '2px solid #fff' : '2px solid transparent',
                                                boxShadow: compareSpeaker === speaker ? '0 0 12px rgba(255, 255, 255, 0.5)' : undefined
                                            }}
                                            title={compareSpeaker === speaker ? 'Click to clear comparison' : `Click to see similarity of all segments to ${speaker}`}
                                        >
                                            {speaker}
                                        </span>
                                    ))}
                                    {compareSpeaker && (
                                        <button
                                            onClick={() => { setCompareSpeaker(null); setSegmentSimilarities({}); }}
                                            style={{
                                                background: 'rgba(255, 255, 255, 0.1)',
                                                border: 'none',
                                                color: '#888',
                                                padding: '4px 8px',
                                                borderRadius: '4px',
                                                cursor: 'pointer',
                                                fontSize: '12px'
                                            }}
                                        >
                                             Clear
                                        </button>
                                    )}
                                </div>
                            )}

                            {duration > 0 && (
                                <>
                                <div 
                                    className="timeline"
                                    onDoubleClick={() => {
                                        if (selection) {
                                            regionsRef.current?.clearRegions();
                                            setSelection(null);
                                            selectionRef.current = null;
                                        }
                                    }}
                                >
                                    {(() => {
                                        const displaySegments = (diarizationMode === 'accurate' && refinedSegments.length > 0)
                                            ? refinedSegments
                                            : segments;
                                        return displaySegments.map((seg, i) => {
                                            const left = (seg.start / duration) * 100;
                                            const width = ((seg.end - seg.start) / duration) * 100;
                                            const isActive = activeSegment && activeSegment.start === seg.start && activeSegment.end === seg.end;
                                            return (
                                                <div
                                                    key={i}
                                                    className={`timeline-segment ${isActive ? 'active' : ''}`}
                                                    onClick={() => seekToSegment(seg)}
                                                    style={{
                                                        left: `${left}%`,
                                                        width: `${width}%`,
                                                        background: getSpeakerColor(seg.speaker, speakerMap),
                                                        cursor: audioBlob ? 'pointer' : 'default'
                                                    }}
                                                    title={`${seg.speaker || 'Unknown'}: ${formatTime(seg.start)} - ${formatTime(seg.end)}${audioBlob ? ' (click to play)' : ''}`}
                                                >
                                                    {width > 10 ? (seg.speaker || '?') : ''}
                                                </div>
                                            );
                                        });
                                    })()}
                                </div>
                                {activeSegment && (
                                    <div className="timeline-info">
                                        <div className="timeline-info-item">
                                            <span className="timeline-info-label">Speaker:</span>
                                            <span className="timeline-info-value" style={{ color: getSpeakerColor(activeSegment.speaker, speakerMap) }}>
                                                {activeSegment.speaker || 'Unknown'}
                                            </span>
                                        </div>
                                        <div className="timeline-info-item">
                                            <span className="timeline-info-label">Start:</span>
                                            <span className="timeline-info-value">{formatTime(activeSegment.start)}</span>
                                        </div>
                                        <div className="timeline-info-item">
                                            <span className="timeline-info-label">Duration:</span>
                                            <span className="timeline-info-value">{(activeSegment.end - activeSegment.start).toFixed(1)}s</span>
                                        </div>
                                        <div className="timeline-info-item">
                                            <span className="timeline-info-label">End:</span>
                                            <span className="timeline-info-value">{formatTime(activeSegment.end)}</span>
                                        </div>
                                        <button 
                                            onClick={clearActiveSegment}
                                            style={{ 
                                                background: 'transparent', 
                                                border: 'none', 
                                                color: '#888', 
                                                cursor: 'pointer',
                                                padding: '0 4px',
                                                fontSize: '16px'
                                            }}
                                            title="Clear selection"
                                        ></button>
                                    </div>
                                )}
                                </>
                            )}

                            <div className="diarization-results">
                                {(() => {
                                    const displaySegments = (diarizationMode === 'accurate' && refinedSegments.length > 0)
                                        ? refinedSegments
                                        : segments;
                                    return displaySegments.map((seg, i) => {
                                        const isActive = activeSegment && activeSegment.start === seg.start && activeSegment.end === seg.end;
                                        const segKey = `${seg.start}-${seg.end}`;
                                        const similarity = segmentSimilarities[segKey];
                                        return (
                                        <div 
                                            key={i} 
                                            className={`segment ${isActive ? 'active' : ''}`}
                                            onClick={() => seekToSegment(seg)}
                                            style={{ cursor: audioBlob ? 'pointer' : 'default' }}
                                            title={audioBlob ? 'Click to play from this segment' : 'Record audio to enable playback'}
                                        >
                                            <span className="segment-time">
                                                {formatTime(seg.start)}  {formatTime(seg.end)}
                                            </span>
                                            {seg.vad_confidence !== undefined && (
                                                <span 
                                                    className={`segment-vad-confidence ${seg.vad_confidence >= 0.8 ? 'high' : seg.vad_confidence >= 0.5 ? 'medium' : 'low'}`}
                                                    title={`VAD confidence: ${(seg.vad_confidence * 100).toFixed(1)}%`}
                                                >
                                                     {(seg.vad_confidence * 100).toFixed(0)}%
                                                </span>
                                            )}
                                            <span 
                                                className={`segment-speaker ${seg.speaker ? 'known' : 'unknown'}`}
                                                style={seg.speaker ? { background: getSpeakerColor(seg.speaker, speakerMap) } : {}}
                                            >
                                                {seg.speaker || 'Unknown Speaker'}
                                            </span>
                                            {compareSpeaker && similarity !== undefined && (
                                                <span 
                                                    className="segment-similarity"
                                                    style={{
                                                        color: similarity >= 0.7 ? '#38ef7d' : similarity >= 0.5 ? '#ffd200' : '#ff6b8a',
                                                        fontWeight: 600,
                                                        fontSize: '13px',
                                                        marginLeft: '8px',
                                                        fontFamily: "'Monaco', 'Consolas', monospace"
                                                    }}
                                                    title={`Similarity to ${compareSpeaker}: ${(similarity * 100).toFixed(1)}%`}
                                                >
                                                    {similarity !== null ? `${(similarity * 100).toFixed(0)}%` : ''}
                                                </span>
                                            )}
                                            {audioBlob && <span className="segment-play-icon">{isActive ? '' : ''}</span>}
                                            {audioBlob && (
                                                <button 
                                                    className="segment-name-btn"
                                                    onClick={(e) => identifySegment(seg, e)}
                                                    disabled={identifyingSegment === segKey}
                                                    title="Identify speaker for this segment"
                                                    style={{ marginLeft: '4px' }}
                                                >
                                                    {identifyingSegment === segKey ? '' : ''} ID
                                                </button>
                                            )}
                                            {audioBlob && (
                                                <button 
                                                    className="segment-name-btn"
                                                    onClick={(e) => openNamingModal(seg, e)}
                                                    title="Name this speaker"
                                                >
                                                     Name
                                                </button>
                                            )}
                                            {segmentIdentifications[segKey]?.top_match && (
                                                <span 
                                                    style={{
                                                        fontSize: '11px',
                                                        color: segmentIdentifications[segKey].top_match.similarity >= 0.7 ? '#38ef7d' : 
                                                               segmentIdentifications[segKey].top_match.similarity >= 0.5 ? '#ffd200' : '#ff6b8a',
                                                        marginLeft: '8px',
                                                        fontFamily: "'Monaco', 'Consolas', monospace"
                                                    }}
                                                    title={`Top matches: ${segmentIdentifications[segKey].matches.map(m => `${m.name}: ${(m.similarity * 100).toFixed(0)}%`).join(', ')}`}
                                                >
                                                     {segmentIdentifications[segKey].top_match.name} ({(segmentIdentifications[segKey].top_match.similarity * 100).toFixed(0)}%)
                                                </span>
                                            )}
                                        </div>
                                        );
                                    });
                                })()}
                            </div>
                        </div>
                    )}

                    {namingSegment && (
                        <div className="modal-overlay" onClick={closeNamingModal}>
                            <div className="modal-content" onClick={e => e.stopPropagation()}>
                                <div className="modal-title"> Name This Speaker</div>
                                
                                <div className="modal-info" style={{ marginBottom: '16px' }}>
                                    Segment: {formatTime(namingSegment.start)}  {formatTime(namingSegment.end)}
                                    {namingSegment.speaker && ` (currently: ${namingSegment.speaker})`}
                                </div>

                                {knownSpeakers.length > 0 && (
                                    <div className="modal-section">
                                        <div className="modal-section-title">Add to existing speaker</div>
                                        <div className="modal-speakers">
                                            {knownSpeakers.map(speaker => (
                                                <div
                                                    key={speaker}
                                                    className={`modal-speaker-option ${selectedExistingSpeaker === speaker ? 'selected' : ''}`}
                                                    style={{ background: getSpeakerColor(speaker, speakerMap) }}
                                                    onClick={() => {
                                                        setSelectedExistingSpeaker(speaker);
                                                        setNewSpeakerName('');
                                                    }}
                                                >
                                                    {speaker}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                <div className="modal-section">
                                    <div className="modal-section-title">
                                        {knownSpeakers.length > 0 ? 'Or create new speaker' : 'Create new speaker'}
                                    </div>
                                    <input
                                        type="text"
                                        className="modal-input"
                                        placeholder="Enter speaker name..."
                                        value={newSpeakerName}
                                        onChange={(e) => {
                                            setNewSpeakerName(e.target.value);
                                            setSelectedExistingSpeaker(null);
                                        }}
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter' && (newSpeakerName.trim() || selectedExistingSpeaker)) {
                                                saveSegmentSpeaker();
                                            }
                                        }}
                                        autoFocus
                                    />
                                </div>

                                <div className="modal-buttons">
                                    <button className="modal-btn modal-btn-cancel" onClick={closeNamingModal}>
                                        Cancel
                                    </button>
                                    <button 
                                        className="modal-btn modal-btn-save" 
                                        onClick={saveSegmentSpeaker}
                                        disabled={isSaving || (!newSpeakerName.trim() && !selectedExistingSpeaker)}
                                    >
                                        {isSaving ? 'Saving...' : 'Save Speaker'}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {events.length > 0 && (
                        <div className="card">
                            <h3> Events Log</h3>
                            <div className="events-log">
                                {events.map((evt, i) => (
                                    <div key={i} className="event-item">
                                        <span className="event-type">[{evt.event}]</span>{' '}
                                        {JSON.stringify(evt)}
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    
                    {/* Saved Recordings Section */}
                    <div className="card">
                        <div className="card-title-row">
                            <h3> Saved Recordings</h3>
                            <button 
                                className="btn-refresh" 
                                onClick={fetchRecordings}
                                title="Refresh recordings list"
                                aria-label="Refresh recordings list"
                            >
                                
                            </button>
                        </div>
                        
                        {savedRecordings.length === 0 ? (
                            <div className="empty-state">
                                No saved recordings yet. Record audio and click Save to keep it for later analysis.
                            </div>
                        ) : (
                            <div className="recordings-list">
                                {savedRecordings.map((recording) => (
                                    <div 
                                        key={recording.id} 
                                        className="recording-item"
                                        onClick={() => loadRecording(recording)}
                                        style={{ cursor: isLoadingRecording ? 'wait' : 'pointer' }}
                                        role="button"
                                        tabIndex={0}
                                        aria-label={`Load recording: ${recording.name}`}
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter' || e.key === ' ') {
                                                e.preventDefault();
                                                loadRecording(recording);
                                            }
                                        }}
                                    >
                                        <span className="recording-icon"></span>
                                        <div className="recording-info">
                                            <div className="recording-name">{recording.name}</div>
                                            <div className="recording-meta">
                                                <span>{formatDate(recording.timestamp)}</span>
                                                <span>{recording.duration > 0 ? formatTime(recording.duration) : '--'}</span>
                                                <span>{formatSize(recording.size)}</span>
                                            </div>
                                        </div>
                                        <div className="recording-actions">
                                            <button
                                                className="btn-small btn-load"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    loadRecording(recording);
                                                }}
                                                disabled={isLoadingRecording || isRecording}
                                                aria-label={`Load ${recording.name}`}
                                            >
                                                 Load
                                            </button>
                                            <button
                                                className="btn-small btn-delete"
                                                onClick={(e) => deleteRecording(recording, e)}
                                                aria-label={`Delete ${recording.name}`}
                                            >
                                                
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<VoiceRecorder />);
    </script>
</body>
</html>